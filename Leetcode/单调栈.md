# 单调栈
#leedcode #algorithm #stack
## 739. 每日温度
题目链接：[739](https://leetcode.cn/problems/daily-temperatures/)  
思路：定义一个从栈顶到栈底递增的栈，记录数组下标。若当前元素小于等于栈顶，说明未找到更高温度，直接入栈即可保持栈单调。若当前元素大于栈顶，说明找到了比栈顶大的元素，两者的下标差即为栈顶元素对应的下标的结果，记录该下标差，并弹出栈顶，继续判断新的栈顶，直至当前元素于等于栈顶，然后入栈。  
代码：
```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        vector<int> result(temperatures.size(), 0);
        stack<int> stk;
        for (int i=0; i<temperatures.size(); ++i) {
            while (!stk.empty() && temperatures[i] > temperatures[stk.top()] ) {
                result[stk.top()] = i - stk.top();
                stk.pop();
            }
            stk.push(i);
        }
        return result;
    }
};
```

## 496 下一个更大元素 I
题目链接：[496](https://leetcode.cn/problems/next-greater-element-i/)  
思路：参考[739. 每日温度](#739.%20每日温度)，用`nums2`来建立单调栈，若找到`nums2`中元素的右侧最大元素，则用哈希表寻找`nums1`中相同元素的下标，并记录在结果数组中。  
代码：
```cpp
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        vector<int> result(nums1.size(), -1);
        stack<int> stk;
        unordered_map<int, int> mp;
        for (int i=0; i<nums1.size(); ++i) {
            mp[nums1[i]] = i;
        }
        for (int i=0; i<nums2.size(); ++i) {
            while (!stk.empty() && nums2[i] > nums2[stk.top()]) {
                if (mp.count(nums2[stk.top()])) {
                    result[mp[nums2[stk.top()]]] = nums2[i];
                }
                stk.pop();
            }
            stk.push(i);
        }
        return result;
    }
};
```

