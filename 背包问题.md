# 背包问题

#data_structure #algorithm
![](Resources/背包问题_img_1.png)
## 0-1背包
有n件物品和一个最多能背重量为 `w` 的背包。第 `i` 件物品的重量是 `weight[i]`，得到的价值是 `value[i]` 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。
### 暴力解法
回溯法
### 动态规划
#### 二维dp数组
1. 定义`dp[i][j]`：下标`[0,i]`的物品任取放在容量为`j`的背包。
2. 对于`dp[i][j]`:
	+ 不放物品`i`：`dp[i-1][j]`。
	+ 放物品`i`：`dp[i-1][j-weight[i]]+value[i]`。
	+ `dp[i][j]=max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])`。
3. 初始化行`i=0`和列`j=0`。
4. 遍历顺序：先遍历物品和先遍历背包都行。

代码：
```cpp
void test_2_wei_bag_problem1() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagweight = 4;

    // 二维数组
    vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));

    // 初始化
    for (int j = weight[0]; j <= bagweight; j++) {
        dp[0][j] = value[0];
    }

    // weight数组的大小 就是物品个数
    for(int i = 1; i < weight.size(); i++) { // 遍历物品
        for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
            if (j < weight[i]) dp[i][j] = dp[i - 1][j];
            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

        }
    }

    cout << dp[weight.size() - 1][bagweight] << endl;
}

int main() {
    test_2_wei_bag_problem1();
}
```
#### 一维滚动数组
1. 定义`dp[j]`：容量为`j`的背包的最大价值。
2. 递推公式 `dp[j]=max(dp[j],dp[j-weight[i]] +value[i])`。
3. 初始化数组`dp[0]=0`。
4. 遍历顺序：先遍历物品再遍历背包，且遍历背包时倒叙遍历，防止同一物体被添加多次。因为根据递推公式，计算`dp[j]`时，`dp[j-weight[i]]`需要为遍历`i-1`层时更新的`dp[j-weight[i]]`，因此需先计算`dp[j]`再计算`dp[j-weight[i]]`。用二维到一维的变换来解释，本质上还是一个对二维数组的遍历，并且右下角的值依赖上一层左上角的值，因此需要保证左边的值仍然是上一层的，从右向左覆盖。