# 秋招八股整理

## C++
### 多态
定义： 同一事物表现出不同事物的能力。（重载实现编译时多态，虚函数实现继承时多态）  
功能：允许将子类指针赋值给父类指针  
实现方式：
+ 覆盖（override)：子类重新定义父类的虚函数
+ 重载（overload)：允许存在多个同名函数，而函数的参数表不同
### 左值和右值
**左值**：可以放在等号左边，**可以取地址**，有名字，表达式结束依然存在 。  
**右值**：不能放在等号左边，**不能取地址**，没名字 ，表达式结束不存在。

字符串字面值“abcd”是左值。

**++i、--i是左值，i++、i--是右值。**

**将亡值**：即将销毁的值，通过盗取其他变量内存空间生存，常用来完成移动构造，如`T&&`函数返回值、`std::move()`返回值和转换为`T&&`类型的转换函数的返回值。

**左值引用**：对左值进行引用，是对象的别名；不拥有绑定对象的堆存，所以必须立即初始化；等号右边必须可以取地址，否则编译失败。

**右值引用**：等号右边的值需要是右值，可以使用`std::move`函数强制把左值转换为右值。右值引用特性允许对右值进行修改，借此实现移动语义。

左值和右值独立于类型，右值引用可能是左值，也可能是右值。  
编译器会将已命名的右值引用视为左值，未命名的右值引用视为右值。

**移动语义**：
+ 转移所有权（转让、资源窃取），将资源转为自己所有，别人不再拥有也不会再使用。
+ 当用右值进行构造时，直接从右值拿数据来初始化/修改左值，不需要先构造左值再析构右值。
+ 通过移动构造函数使用移动语义，也就是`std:move`；移动语义仅针对实现了移动构造函数的类和对象；若没有移动构造函数，则无任何优化作用。
+ 浅拷贝：数据的简单赋值，对于指针、引用仍指向同一块内存
+ 深拷贝：若被拷贝对象内部还有指针引用指向其他资源，则需重新开辟一块新内存

对于一个具体的类型，如`string`，
```cpp
void my_copy(const string& str) {
  string x = str;
}
```
`const string&`为常左值引用，可以匹配左值和右值：
+ 匹配左值时，为常左值引用
+ 匹配右值时，优先为右值引用实现移动语义，但也可以为常左值引用
```cpp
void my_copy(string&& str) {
  string x = str;
}
```
`string&&`只能匹配右值

对于函数模板的的类型参数`T`，`T&&`成为了**universal reference**。  
**universal reference:**
```cpp
template<typename T>
void calc(T&& t) {
  T x = std::forward<T>(t);
}
```
此时，`T&&`既可以传递左值，又可以传递右值，配合完美转发`std::forward`来使用，可将参数转发给其他函数，并保持左值为左值，右值为右值。

`auto&&`和`T&&`都是未定的引用类型，都是universal reference，取决于初始化的值类型。

**完美转发**：写一个接受任意实参的函数模板，并转发到其他函数，目标函数会收到与转发函数完全相同的实参，通过`std::forward`实现。  
如果没有完美转发，
```cpp
template<typename T>
void calc(T&& t) {
  T x = t;  // 这里的t为左值
}
```
在函数中直接使用了右值的名称，则右值会变为左值。

在一个模板类的成员函数中，
```cpp
template<typename T>
class Person {
 public:
  void eat(T&& t);
}
```
`T&&`只能接受右值，因为在创建类的时候，`T`的类型就确定了，确定类型的右值引用只能匹配右值。

**右值引用叠加到右值引用仍是右值引用，其他引用折叠都为左值引用。**

### 智能指针
智能指针是用于管理指针的类，可以**在特定情况下自动释放内存空间，无需手动释放**，避免忘记释放导致的内存泄露。

**auto_ptr**：C++11废弃，所有权模式
```cpp
auto_ptr<std::string> p1 (new string ("hello"));
auto_ptr<std::string> p2;
p2 = p1; //auto_ptr 不会报错.
```
`p2`剥夺了`p1`的所有权，再次访问`p1`会报错，因此**存在潜在的内存崩溃**问题。

**unique_ptr**：替换auto_ptr
```
unique_ptr<string> p3 (new string (auto));//#4
unique_ptr<string> p4； //#5
p4 = p3;//此时会报错
```
+ **独占式**，严格拥有，**同一时间只有一个智能指针能指向该对象**，对于避免泄露很有用，比auto_ptr更安全。
+ 不支持普通的拷贝和赋值，但可以通过`release`或`reset`将指针从一个unique_ptr转移到另一个unique_ptr。

**shared_ptr**：共享型，强引用。  
+ **共享式拥有**，多个智能指针能指向相同对象，该对象和其相关资源会**在“最后一个引用”被销毁时释放**，使用**计数机制**来表明资源被几个指针共享。  
+ 可通过`use_count`函数来查看所有者个数。  
+ 调用`release()`时会释放所有权，计数减一。计数为0时资源释放。  
+ shared_ptr 是为了**解决 auto_ptr 在对象所有权上的局限性** (auto_ptr 是独占的)，在使⽤引⽤计数的机制上提供了可以共享所有权的智能指针。
+ **线程安全**：
	+ 同一个shared_ptr被多个线程**读**是**安全**
	+ 同一个shared_ptr被多个线程**写**是**不安全**
	+ 共享引⽤计数的不同的shared_ptr被多个线程”写“ 是安全的

**weak_ptr**：弱引用  
+ **不控制对象生命周期**，**只提供对管理对象的一个访问手段**，**构造和析构不会引起计数的增加或减少**。  
+ 它只能从shared_ptr和weak_ptr对象构造，指向一个shared_ptr管理的对象，但只有shared_ptr会管理对象内存。可以和shared_ptr相互转化， shared_ptr可以直接赋值给它，它可以调用`lock`获得shared_ptr。  
+ weak_ptr的目的是配合shared_ptr工作，解决shared_ptr相互引用时的死锁问题。若shared_ptr相互引⽤，析构时两个资源引⽤计数会减⼀，但是两者引⽤计数还是为 1，资源没有被释放。将其中一个改为weak_ptr即可。

### Lambda表达式
Lambda表达式提供了类似**匿名函数**的特性。
+ 可编写内嵌的匿名函数，以替换独立函数或函数对象
+ 本质上是语法糖，只是为了简化语法
+ 返回值可自动推导，也可指定
```cpp
// 指明返回类型，托尾返回类型
auto add = [](int a, int b) -> int { return a + b; };
// ⾃动推断返回类型
auto multiply = [](int a, int b) { return a * b; };
int sum = add(2, 5); // 输出： 7
int product = multiply(2, 5); // 输出： 10
```
`[]`是lambda表达式的重要功能，**闭包**。

原理：定义一个lambda表达式，自动生成一个匿名类（重载了`()`运算符），称为闭包类型。  
运行时，lambda表达式返回一个匿名的闭包实例（**右值**）。  

闭包**可通过传值或引用的方式捕捉其封装作用域内的变量**，而`[]`就是用来定义捕捉模式及变量的，又称为**lambda捕捉块**。

lambda表达式的**捕获类型**：
+ []：默认不捕获任何变量；
+ [=]：默认以值捕获所有变量；
+ [&]：默认以引⽤捕获所有变量；
+ [x]：仅以值捕获x，其它变量不捕获；
+ [&x]：仅以引⽤捕获x，其它变量不捕获；
+ [=, &x]：默认以值捕获所有变量，但是x是例外，通过引⽤捕获；
+ [&, x]：默认以引⽤捕获所有变量，但是x是例外，通过值捕获；
+ [this]：通过引⽤捕获当前对象（其实是复制指针）；
+ [*this]：通过传值⽅式捕获当前对象；

**lambda表达式的重要应用：可用于函数参数，从而实现回调函数**，如STL算法中通过lambda表达式给出条件。