# 秋招八股整理

## C++
### 多态
定义： 同一事物表现出不同事物的能力。（**重载实现编译时多态，虚函数实现运行时多态**）  
功能：允许将父对象设置成和一个或更多他的子对象相等的技术，赋值后，父对象会根据当前赋值给它的子对象特性以不同方式运作。**允许将子类指针赋值给父类指针**  。
实现方式：
+ **覆盖（override)**：子类重新定义父类的虚函数
+ **重载（overload)**：允许存在多个同名函数，而函数的参数表不同

狭义：继承+虚函数实现的多态。

### 虚函数（虚函数表、虚函数指针、实现原理）
表象：基类函数加上`virtual`关键字，在派生类中重写该函数，运行时会根据对象实际类型调用相应函数。

**虚函数表**：
+ 当类中包含虚函数时，编译器为该类**生成虚函数表，保存虚函数地址**。
+ 派生类继承基类，编译器**为派生类生成自己的虚函数表**。

**虚函数指针**：
+ 定义一个类对象时，**编译器检测有虚函数，为该对象生成一个虚函数指针，指向该类型的虚函数表**，虚函数指针的初始化在构造函数中完成。
+ 若有基类指针指向派生类，**调用虚函数时，会根据所指对象的虚函数指针找到对应的虚函数表，从而找虚函数地址**。

**编译器对虚函数表的处理**：
对于派生类，编译器建立虚函数表一共三步：
1. **拷贝**基类的虚函数表，若是**多继承，则拷贝每个有虚函数基类的虚函数表**
2. 当然还有⼀个基类的虚函数表和派⽣类⾃身的虚函数表共⽤了⼀个虚函数表，也称为某个基类为派⽣类的主基类。
3. 查看派生类中是否有重写基类的虚函数，若有，就替换成重写的虚函数地址
4. 查看派生类是否有自己的虚函数，若有，则将自身虚函数加到虚函数表中（主基类的表后）

**析构函数一般写为虚函数**：降低内存泄漏。  
举例：一个基类指针指向派生类对象，若基类析构函数没有定义为虚函数，则销毁时仅执行基类的析构函数，派生类内容无法析构，导致内存泄露。若定义为虚函数，则会先执行派生类的析构，再执行基类析构，成功释放内存。

**构造函数一般不定义为虚函数**：  
+ 虚函数调用只需“部分”信息，即只需知道函数接口，无需对象的具体类型；但创建对象是需要知道对象的完整信息的，特别是确切类型。
+ 从编译器实现虚函数进行多态的方式看，虚函数的调用是通过实例化对象后对象的虚函数表指针来找到虚函数地址进行调用，在构造前虚函数指针不存在，若构造函数为虚，则无法找到对应的虚函数表，违反了先实例再调用的准则。

**不应该在构造或析构函数中调用虚函数：**
+ 创建派生类对象时，会先创建基类部分，执行基类的构造函数，此时派生类部分还未被创建，因此编译器认为这就是一个基类类型，调用基类中的虚函数。
+ 派生类对象执行析构，会先析构派生类部分，派生类自身成员呈现未定义状态，此时执行基类的析构不可能调用派生类重写的方法。


### 虚基类
![](../Resource/八股整理_img_1.png)
A是B、C的基类，而B、C又是D的基类，此时，类D会继承B与C的多份同名成员。  
也就是说，在**继承共同间接基类时，会保留多份数据成员的拷贝**，不仅占用内存，还会增加访问成员时的难度。  
**虚基类**可以**继承共同间接基类时只保留一份成员。**
### 左值和右值
**左值**：可以放在等号左边，**可以取地址**，有名字，表达式结束依然存在 。  
**右值**：不能放在等号左边，**不能取地址**，没名字 ，表达式结束不存在。

字符串字面值“abcd”是左值。

**++i、--i是左值，i++、i--是右值。**

**将亡值**：即将销毁的值，通过盗取其他变量内存空间生存，常用来完成移动构造，如`T&&`函数返回值、`std::move()`返回值和转换为`T&&`类型的转换函数的返回值。

**左值引用**：对左值进行引用，是对象的别名；不拥有绑定对象的堆存，所以必须立即初始化；等号右边必须可以取地址，否则编译失败。

**右值引用**：等号右边的值需要是右值，可以使用`std::move`函数强制把左值转换为右值。右值引用特性允许对右值进行修改，借此实现移动语义。

左值和右值独立于类型，右值引用可能是左值，也可能是右值。  
编译器会将已命名的右值引用视为左值，未命名的右值引用视为右值。

**移动语义**：
+ 转移所有权（转让、资源窃取），将资源转为自己所有，别人不再拥有也不会再使用。
+ 当用右值进行构造时，直接从右值拿数据来初始化/修改左值，不需要先构造左值再析构右值。
+ 通过移动构造函数使用移动语义，也就是`std:move`；移动语义仅针对实现了移动构造函数的类和对象；若没有移动构造函数，则无任何优化作用。
+ 浅拷贝：数据的简单赋值，对于指针、引用仍指向同一块内存
+ 深拷贝：若被拷贝对象内部还有指针引用指向其他资源，则需重新开辟一块新内存

对于一个具体的类型，如`string`，
```cpp
void my_copy(const string& str) {
  string x = str;
}
```
`const string&`为常左值引用，可以匹配左值和右值：
+ 匹配左值时，为常左值引用
+ 匹配右值时，优先为右值引用实现移动语义，但也可以为常左值引用
```cpp
void my_copy(string&& str) {
  string x = str;
}
```
`string&&`只能匹配右值

对于函数模板的的类型参数`T`，`T&&`成为了**universal reference**。  
**universal reference:**
```cpp
template<typename T>
void calc(T&& t) {
  T x = std::forward<T>(t);
}
```
此时，`T&&`既可以传递左值，又可以传递右值，配合完美转发`std::forward`来使用，可将参数转发给其他函数，并保持左值为左值，右值为右值。

`auto&&`和`T&&`都是未定的引用类型，都是universal reference，取决于初始化的值类型。

**完美转发**：写一个接受任意实参的函数模板，并转发到其他函数，目标函数会收到与转发函数完全相同的实参，通过`std::forward`实现。  
如果没有完美转发，
```cpp
template<typename T>
void calc(T&& t) {
  T x = t;  // 这里的t为左值
}
```
在函数中直接使用了右值的名称，则右值会变为左值。

在一个模板类的成员函数中，
```cpp
template<typename T>
class Person {
 public:
  void eat(T&& t);
}
```
`T&&`只能接受右值，因为在创建类的时候，`T`的类型就确定了，确定类型的右值引用只能匹配右值。

**右值引用叠加到右值引用仍是右值引用，其他引用折叠都为左值引用。**

### 智能指针
智能指针是用于管理指针的类，可以**在特定情况下自动释放内存空间，无需手动释放**，避免忘记释放导致的内存泄露。

**auto_ptr**：C++11废弃，所有权模式
```cpp
auto_ptr<std::string> p1 (new string ("hello"));
auto_ptr<std::string> p2;
p2 = p1; //auto_ptr 不会报错.
```
`p2`剥夺了`p1`的所有权，再次访问`p1`会报错，因此**存在潜在的内存崩溃**问题。

**unique_ptr**：替换auto_ptr
```
unique_ptr<string> p3 (new string (auto));//#4
unique_ptr<string> p4； //#5
p4 = p3;//此时会报错
```
+ **独占式**，严格拥有，**同一时间只有一个智能指针能指向该对象**，对于避免泄露很有用，比auto_ptr更安全。
+ 不支持普通的拷贝和赋值，但可以通过`release`或`reset`将指针从一个unique_ptr转移到另一个unique_ptr。

**shared_ptr**：共享型，强引用。  
+ **共享式拥有**，多个智能指针能指向相同对象，该对象和其相关资源会**在“最后一个引用”被销毁时释放**，使用**计数机制**来表明资源被几个指针共享。  
+ 可通过`use_count`函数来查看所有者个数。  
+ 调用`release()`时会释放所有权，计数减一。计数为0时资源释放。  
+ shared_ptr 是为了**解决 auto_ptr 在对象所有权上的局限性** (auto_ptr 是独占的)，在使⽤引⽤计数的机制上提供了可以共享所有权的智能指针。
+ **线程安全**：
	+ 同一个shared_ptr被多个线程**读**是**安全**
	+ 同一个shared_ptr被多个线程**写**是**不安全**
	+ 共享引⽤计数的不同的shared_ptr被多个线程”写“ 是安全的

**weak_ptr**：弱引用  
+ **不控制对象生命周期**，**只提供对管理对象的一个访问手段**，**构造和析构不会引起计数的增加或减少**。  
+ 它只能从shared_ptr和weak_ptr对象构造，指向一个shared_ptr管理的对象，但只有shared_ptr会管理对象内存。可以和shared_ptr相互转化， shared_ptr可以直接赋值给它，它可以调用`lock`获得shared_ptr。  
+ weak_ptr的目的是配合shared_ptr工作，解决shared_ptr相互引用时的死锁问题。若shared_ptr相互引⽤，析构时两个资源引⽤计数会减⼀，但是两者引⽤计数还是为 1，资源没有被释放。将其中一个改为weak_ptr即可。

### Lambda表达式
Lambda表达式提供了类似**匿名函数**的特性。
+ 可编写内嵌的匿名函数，以替换独立函数或函数对象
+ 本质上是语法糖，只是为了简化语法
+ 返回值可自动推导，也可指定
```cpp
// 指明返回类型，托尾返回类型
auto add = [](int a, int b) -> int { return a + b; };
// ⾃动推断返回类型
auto multiply = [](int a, int b) { return a * b; };
int sum = add(2, 5); // 输出： 7
int product = multiply(2, 5); // 输出： 10
```
`[]`是lambda表达式的重要功能，**闭包**。

原理：定义一个lambda表达式，自动生成一个匿名类（重载了`()`运算符），称为闭包类型。  
运行时，lambda表达式返回一个匿名的闭包实例（**右值**）。  

闭包**可通过传值或引用的方式捕捉其封装作用域内的变量**，而`[]`就是用来定义捕捉模式及变量的，又称为**lambda捕捉块**。

lambda表达式的**捕获类型**：
+ []：默认不捕获任何变量；
+ [=]：默认以值捕获所有变量；
+ [&]：默认以引⽤捕获所有变量；
+ [x]：仅以值捕获x，其它变量不捕获；
+ [&x]：仅以引⽤捕获x，其它变量不捕获；
+ [=, &x]：默认以值捕获所有变量，但是x是例外，通过引⽤捕获；
+ [&, x]：默认以引⽤捕获所有变量，但是x是例外，通过值捕获；
+ [this]：通过引⽤捕获当前对象（其实是复制指针）；
+ [*this]：通过传值⽅式捕获当前对象；

**lambda表达式的重要应用：可用于函数参数，从而实现回调函数**，如STL算法中通过lambda表达式给出条件。

### using namespace std 和 using std::cin
+ `using namespace std`在当前作用域引入`std`命名空间的所有成员，可能导致命名冲突。
+ `using std::cin`只将`std`命名空间的`cin`引入当前作用域，避免了引入不需要的成员。

### 内存模型
+ 栈：局部变量、函数参数
+ 堆：由程序员管理，手动分配和回收（new, malloc, free, delete），空间较大，但可能出现内存泄露和空闲碎片的情况
+ 全局/静态存储区：分为初始化和未初始化两个区，存放初始化和未初始化的全局和静态变量
+ 常量存储区：存储常量，一般不允许修改
+ 代码区：存放程序的二进制代码

### const

**const修饰基本数据类型**：const可在类型说明符前，也可在说明符后。在使用常量时，只要不改变常量值即可。

**const修饰指针变量和应用变量**：
+ const在\*的左侧：修饰指针所指向的变量，即指针指向为常量
+ const在\*的右侧：修饰指针本身，即指针本身为常量

**const用在函数中**：
+ 修饰参数：调用函数时，用相应的变量初始化const常量，在函数体中，按照const所修饰的部分进行常量化，保护原对象属性
