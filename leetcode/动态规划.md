# 动态规划
#leedcode #algorithm #dp #dynamic_programming
## LeetCode 509 斐波那契数
题目链接：[509](https://leetcode.cn/problems/fibonacci-number/)  
思路：
1. 首先定义数组`dp[i]`，代表第`i`个斐波那契数。
2. 根据斐波那契数列性质，得递推公式`dp[i]=dp[i-1]+dp[i-2]`。
3. 由题得初始条件`dp[0]=0, dp[1]=1`。
4. 由于后面的数依赖前两个数，因此遍历顺序从前往后

代码：
```cpp
class Solution {
public:
    int fib(int n) {
        vector<int> dp(n+1);
        if (n <= 1) return n;
        dp[0] = 0;
        dp[1] = 1;
        for (int i=2; i<=n; ++i) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
};
```
代码：空间优化，只保存两个数
```cpp
class Solution {
public:
    int fib(int n) {
        vector<int> dp(2);
        if (n <= 1) return n;
        dp[0] = 0;
        dp[1] = 1;
        for (int i=2; i<=n; ++i) {
            int sum = dp[0] + dp[1];
            dp[0] = dp[1];
            dp[1] = sum;
        }
        return dp[1];
    }
};
```
## LeetCode 70 爬楼梯
题目链接：[70](https://leetcode.cn/problems/climbing-stairs/)  
思路：
1. 首先定义数组`dp[i]`，代表第`i`个斐波那契数。
2. 根据斐波那契数列性质，得递推公式`dp[i]=dp[i-1]+dp[i-2]`。
3. 由题得初始条件`dp[0]=0, dp[1]=1`。
4. 由于后面的数依赖前两个数，因此遍历顺序从前往后

代码：
```cpp

```