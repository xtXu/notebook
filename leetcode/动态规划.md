# 动态规划
#leedcode #algorithm #dp #dynamic_programming
## LeetCode 509 斐波那契数
题目链接：[509](https://leetcode.cn/problems/fibonacci-number/)  
思路：
1. 首先定义数组`dp[i]`，代表第`i`个斐波那契数。
2. 根据斐波那契数列性质，得递推公式`dp[i]=dp[i-1]+dp[i-2]`。
3. 由题得初始条件`dp[0]=0, dp[1]=1`。
4. 由于后面的数依赖前两个数，因此遍历顺序从前往后。

代码：
```cpp
class Solution {
public:
    int fib(int n) {
        vector<int> dp(n+1);
        if (n <= 1) return n;
        dp[0] = 0;
        dp[1] = 1;
        for (int i=2; i<=n; ++i) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
};
```
代码：空间优化，只保存两个数
```cpp
class Solution {
public:
    int fib(int n) {
        vector<int> dp(2);
        if (n <= 1) return n;
        dp[0] = 0;
        dp[1] = 1;
        for (int i=2; i<=n; ++i) {
            int sum = dp[0] + dp[1];
            dp[0] = dp[1];
            dp[1] = sum;
        }
        return dp[1];
    }
};
```
## LeetCode 70 爬楼梯
题目链接：[70](https://leetcode.cn/problems/climbing-stairs/)  
思路：
1. 首先定义数组`dp[i]`，代表爬到第`i`阶有几种方法。
2. 爬到第`i`阶，有两种情况，从`i-1`阶爬1步或从`i-2`阶爬2步。到`i-1`阶有`dp[i-1]`种方法，到`i-2`阶有`dp[i-2]`种方法，前两种情况互不重复，因此得递推公式`dp[i]=dp[i-1]+dp[i-2]`。
3. 由于爬到第0阶没有讨论意义，因此初始条件直接从`1`开始考虑，`dp[1]=1,dp[2]=2`。
4. 遍历顺序从前往后。

代码：
```cpp
class Solution {
public:
    int climbStairs(int n) {
        if (n <= 1) return n;
        vector<int> dp(n+1);
        dp[1] = 1;
        dp[2] = 2;
        for (int i=3; i<=n; ++i) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
};
```
## 746 使用最小花费爬楼梯
题目链接：[746](https://leetcode.cn/problems/min-cost-climbing-stairs/)  
思路：
1. 首先定义数组`dp[i]`，代表爬到第`i`阶的最小步数。
2. 爬到第`i`阶，有两种情况，从`i-1`阶爬1步或从`i-2`阶爬2步。到`i-1`阶的最小花费为`cost[i-1]`，到`i-2`阶的最小花费为`cost[i-2]`，则爬到第`i`阶的最小花费为（递推公式）`dp[i]=min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]`。
3. 可以从第0阶或第1阶开始爬，因此`dp[0]=0,dp[1]=0`。
4. 遍历顺序从前往后。

代码：
```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        if (cost.size() <= 1) return 0;
        vector<int> dp(cost.size()+1);
        dp[0] = 0;
        dp[1] = 0;
        for (int i=2; i<dp.size(); ++i) {
            dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2]);
        }
        return dp.back();
    }
};
```

## 62 不同路径
题目链接：[62](https://leetcode.cn/problems/unique-paths/)  
### 图论
思路：每次只能向下或向右走，因此可以将该过程抽象为一棵二叉树；到达终点及叶子节点为终点，可通过DFS遍历得到符合的叶子节点数。
### 数论
思路：不论怎么走，都是走 $m-n-2$ 步到达，其中有 $m-1$ 步向下，$n-1$ 步向右。因此，总次数为 $C_{m-n-2}^{m-1}$。
### 动态规划
思路：
1. 首先定义数组`dp[i][j]`，代表走到`[i,j]`的不同路径数。
2. 走到`[i,j]`，有两种情况，即从`[i-1,j]`向下走或从`[i,j-1]`向下走。因此递推公式 `dp[i][j] = dp[i-1][j] + dp[i][j-1]`。注意在第一行或第一列时只有一种情况。
3. 起点只有一种走法，`dp[0][0]=1`。
4. 遍历顺序从左到右，从上到下，保证计算`dp[i][j]`时`dp[i-1][j]`和`dp[i][j-1]`都计算过。  

代码：
```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n));
        dp[0][0] = 1;
        for (int i=0; i<m; i++) {
            for (int j=0; j<n; j++) {
                if (i > 0) dp[i][j] += dp[i-1][j];
                if (j > 0) dp[i][j] += dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
};
```
代码：一维滚动数组->空间优化
```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<int> dp(n, 1);
        for (int i=1; i<m; i++) {
            for (int j=1; j<n; j++) {
                dp[j] += dp[j-1];
            }
        }
        return dp[n-1];
    }
};
```
## 63 不同路径 II
题目链接：[63](https://leetcode.cn/problems/unique-paths-ii/)  
### 动态规划
思路：与[62 不同路径](#62%20不同路径)类似，只不过当`(i,j)`为障碍物时，`dp[i][j] = 0`。  
代码：
```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        if (obstacleGrid[0][0] == 1 || obstacleGrid[m-1][n-1] == 1) return 0;
        dp[0][0] = 1;
        for (int i=0; i<dp.size(); i++) {
            for (int j=0; j<dp[0].size(); j++) {
                if (obstacleGrid[i][j] == 1) continue;
                if (i > 0) dp[i][j] += dp[i-1][j];
                if (j > 0) dp[i][j] += dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
};
```
代码：一维滚动数组->空间优化
```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        if (obstacleGrid[0][0] == 1 || obstacleGrid[m-1][n-1] == 1) return 0;
        vector<int> dp(n, 0);
        for (int i=0; i<n; i++) {
            if (obstacleGrid[0][i] == 1) break;
            dp[i] = 1;
        }
        for (int i=1; i<m; i++) {
            if (obstacleGrid[i][0] == 1) dp[0] = 0;
            for (int j=1; j<n; j++) {
                if (obstacleGrid[i][j] == 1) {
                    dp[j] = 0;
                } else {
                    dp[j] += dp[j-1];
                }
            }
        }
        return dp[n-1];
    }
};
```
## 343 整数拆分
题目链接：[343](https://leetcode.cn/problems/integer-break/)  
思路：
1. 首先定义数组`dp[i]`，代表拆分数字`i`可得的最大乘积。
2. 考虑`dp[i]`，从1开始遍历`j`，将`i`拆分为`j+(i-j)`，有两种情况可以得到`dp[i]`：`j*(i-j)`和`j*dp[i-j]`，分别代表将`i`拆分为两个数的情况和拆为两个以上的情况。为了取到最大，得递推公式`dp[i]=max(dp[i], j*(i-j), j*dp[i-j])`。
3. 初始化时，由于`i`为0或1时都没什么意义，因此初始化`dp[2]=1`，然后从`i=3`开始遍历。
4. 从前向后遍历。  

注意：要拆分`n`使得乘积最大，一定是拆分成`m`个近似相同的子数相乘。虽然`m`未知，但一定大于等于2，因此`j`遍历到`i/2`即可。
代码：
```cpp
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n+1);
        dp[2] = 1;
        for (int i=3; i<=n; ++i) {
            for (int j=1; j<=i/2; ++j) {
                dp[i] = max(dp[i], max(j*(i-j), j*dp[i-j]));
            }
        }
        return dp[n];
    }
};
```


## 96 不同的二叉搜索树
题目链接：[96](https://leetcode.cn/problems/unique-binary-search-trees/)  
思路：
1. 首先定义数组`dp[i]`，代表由`i`个数`[1,i]`能组成的二叉搜索树的数量。
2. 考虑`dp[i]`，则根结点可以是`[1,i]`；若选择头结点为`j`，则左子树为由`[1,j-1]`构成的二叉搜索树，种类数为`dp[j-1]`，右子树为`[j+1,i]`构成的二叉搜索树，由于`k`个节点构成的二叉搜索树的结构种类是相同的，因此右子树的种类数为`dp[i-(j+1)+1]=dp[i-j]`，则总的可能数为`dp[j-1]*dp[i-j]`；可得递推公式 $\text{dp}[i]=\sum_{j=1}^{i}\text{dp}[j-1]\text{dp}[i-j]$。
3. 当`i`为0时，空树也为一种可能，因此`dp[0]=0`。
4. 节点数的遍历`i`从小到大，每个遍历里头结点`j`的遍历也从小到大。  
代码：
```cpp
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+1, 0);
        dp[0] = 1;
        for (int i=1; i<=n; ++i) {
            for (int j=1; j<=i; ++j) {
                dp[i] += dp[j-1] * dp[i-j];
            }
        }
        return dp[n];
    }
};
```
