# 回溯算法
#leedcode #algorithm #backtracking
## LeetCode 77 组合
题目链接：[77](https://leetcode.cn/problems/combinations/)  
思路：可以这么理解，我要从 $[1,n]$ 中选出 $k$ 个元素，则先从原数组中选择一个 $i$，为避免重复，再从 $[i+1,n]$ 中选出 $k-1$ 个，原问题和子问题相同就可以用递归；由于是求所有组合，因此单个元素的选择需考虑所有情况，因此递归就应写在一个`for`循环中，这也和回溯模板相对应。
### 未剪枝
代码：
```cpp
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;

    void backtracking(int start, int n, int k) {
        if (path.size() == k) {
            result.push_back(path);
            return;
        }

        for (int i=start; i<=n; ++i) {
            path.push_back(i);
            backtracking(i+1, n, k);
            path.pop_back();
        }
    }

    vector<vector<int>> combine(int n, int k) {
        backtracking(1, n, k);
        return result;
    }
};
```
### 剪枝
思路：假设当前层递归考虑的是 $[i,n]$，已确定元素个数为`path.size()`，则还需确定 `k-path.size()`个元素，接下来考虑的数组为 $[x,n]$，则大小一定大于等于`k-path.size()`，即`n-x+1>=k-path.size()`，`x<=n-(k-path.size())+1`，因此循环时只需循环至 `n-(k-path.size())+1`，后面的数组大小一定无法满足找到符合要求的组合，可直接不考虑。  
代码：
```cpp
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;

    void backtracking(int start, int n, int k) {
        if (path.size() == k) {
            result.push_back(path);
            return;
        }

        for (int i=start; i<=(n-(k-path.size())+1); ++i) {
            path.push_back(i);
            backtracking(i+1, n, k);
            path.pop_back();
        }
    }

    vector<vector<int>> combine(int n, int k) {
        backtracking(1, n, k);
        return result;
    }
};
```

## LeetCode 216 组合总和III
题目链接：[216](https://leetcode.cn/problems/combination-sum-iii/)  
思路：与77类似，先取在当前数组中 $[i,9]$ 取一个数 $k$，再递归右侧数组 $[k+1,9]$。考虑两种情况的剪枝：1. `sum`已经大于目标；2. $[k+1,9]$ 的个数不足。  
代码：
```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;

    void backtracking(int start, int sum, int k, int n) {
        if (path.size() == k) {
            if (sum == n) result.push_back(path);
            return;
        }
        if (sum > n) return;

        for (int i=start; i<=9-(k-path.size())+1; ++i) {
            path.push_back(i);
            backtracking(i+1, sum+i, k, n);
            path.pop_back();
        }
    }

    vector<vector<int>> combinationSum3(int k, int n) {
        result.clear();
        path.clear();
        backtracking(1, 0, k, n);
        return result;
    }
};
```

## LeetCode 17 电话号码的字母组合
题目链接：[17](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)  
思路：相当于根据数字映射，对每个`digits`中的元素取一个值。因此树的深度等于`digits`的`size`，`for`循环的范围为当前元素对应的字符集合。  
代码：
```cpp
class Solution {
public:

    const vector<string> digit2letter = {
        "",
        "",
        "abc",
        "def",
        "ghi",
        "jkl",
        "mno",
        "pqrs",
        "tuv",
        "wxyz"
    };

    vector<string> result;
    string str;

    void backtracking(string& digits, int idx) {
        if (idx == digits.size()) {
            result.push_back(str);
            return;
        }

        string letter = digit2letter[digits[idx]-'0'];
        for (int i=0; i<letter.size(); ++i) {
            str.push_back(letter[i]);
            backtracking(digits, idx+1);
            str.pop_back();
        }
    }
    
    vector<string> letterCombinations(string digits) {
        result.clear();
        str.clear();
        if (digits.empty()) return result;
        backtracking(digits, 0);
        return result;
    }
};
```

## LeetCode 39 组合总和
题目链接：[39](https://leetcode.cn/problems/combination-sum/)  
思路：由于数组中的元素可重复选取，因此每次选完当前元素后，递归数组的`startIndex`与当前`index`相同。  
代码：
```cpp
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;
    int sum = 0;
    
    void backtracking(vector<int>& candidates, int start, int target) {
        if (sum == target) {
            result.push_back(path);
            return;
        }
        if (sum > target) return;

        for (int i=start; i<candidates.size(); ++i) {
            path.push_back(candidates[i]);
            sum += candidates[i];
            backtracking(candidates, i, target);
            sum -= candidates[i];
            path.pop_back();
        }
    }

    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        path.clear();
        result.clear();
        backtracking(candidates, 0, target);
        return result;
    }
};
```

## LeetCode 40 组合总和 II
题目链接：[40](https://leetcode.cn/problems/combination-sum-ii/)  
思路：数组中的元素不可重复选取，但数组中存在重复元素。为了去重，首先对原数组进行排序，防止由于顺序不同导致的重复。这样，得到的所有组合都将按序排列，且搜索时重复元素一定相邻。在单层递归中，由于元素在同一个组合内可以重复，但两个组合不能重复，因此需避免同一树层的重复，即在`for`循环中，与前一元素相等的元素不应选取。具体来说，假设当前已选择的组合为 $A=\{a_1,\cdots,a_i\}$ ，待选择的数组元素集合$B=\{b_1,b_2,\cdots\}$。本次选择了 $b_1$，则通过递归能搜索到由 $A\cup b_1$ 开始的所有组合；下次选择 $b_2$ 时，若 $b_1=b_2$，则由 $A\cup b_2$ 开始的所有组合一定是由$A\cup b_1$ 开始的所有组合的子集，因此会导致重复，此时避免选择 $b_2$ 即避免同一数层上的遍历。  
代码：
```cpp
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;
    int sum = 0;

    void backtracking(vector<int>& candidates, int start, int target) {
        if (sum == target) {
            result.push_back(path);
            return;
        }

        for (int i=start; i<candidates.size() && sum+candidates[i] <= target; ++i) {
            if (i > start && candidates[i] == candidates[i-1]) continue;
            path.push_back(candidates[i]);
            sum += candidates[i];
            backtracking(candidates, i+1, target);
            sum -= candidates[i];
            path.pop_back();
        }
    }

    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        path.clear();
        result.clear();
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, 0, target);
        return result;
    }
};
```

## LeetCode 131 分割回文串
题目链接：[131](https://leetcode.cn/problems/palindrome-partitioning/)  
思路：分割问题可以看作组合问题的变形。先选取一个分割点，再在分割点右侧子数组中选取下一个分割点，若分割到数组末尾则分割结束。回文串的判断采用双指针法。  
代码：
```cpp
class Solution {
public:
    vector<string> str;
    vector<vector<string>> result;

    bool isPalindrome(string& s) {
        int left = 0;
        int right = s.size()-1;
        while (left < right) {
            if (s[left++] != s[right--]) return false;
        }
        return true;
    }

    void backtracking(string& s, int start) {
        if (start == s.size()) {
            result.push_back(str);
            return;
        }

        for (int i=start+1; i<=s.size(); ++i) {
            string temp(s.begin()+start, s.begin()+i);
            if (!isPalindrome(temp)) continue;
            str.push_back(temp);
            backtracking(s, i);
            str.pop_back();
        }
    }

    vector<vector<string>> partition(string s) {
        str.clear();
        result.clear();
        backtracking(s, 0);
        return result;
    }
};
```
## LeetCode 93 复原IP地址
题目链接：[93](https://leetcode.cn/problems/restore-ip-addresses/)  
思路：本题也是分割问题。题目确定了分割段数为4段，而割3次就能确定4段。因此，终止条件为分割3次时，判断第4段是否合法，若合法则加入`result`。具体的分割操作为在原字符串中加入`.`。判断每段地址的合法性：长度不为0，不出现除数字外的其他字符，不含前导`0`，小于255。  
代码：
```cpp
class Solution {
public:
    vector<string> result;

    bool isValid(const string& s, int start, int end) {
        if (start > end) return false;
        if (s[start] == '0' && start != end) return false;
        for (int i=start; i<=end; ++i) {
            if (s[i] < '0' || s[i] > '9') return false;
        }
        if (stol(s.substr(start, end-start+1)) > 255) return false;
        return true;
    }

    void backtracking(string& s, int start, int cnt) {
        if (cnt == 3) {
            if (isValid(s, start, s.size()-1)) result.push_back(s);
            return;
        }

        for (int i=start; i<s.size(); ++i) {
            if (!isValid(s, start, i)) break;
            s.insert(s.begin()+i+1, '.');
            backtracking(s, i+2, cnt+1);
            s.erase(s.begin()+i+1);
        }
    }

    vector<string> restoreIpAddresses(string s) {
        result.clear();
        if (s.size() < 4 || s.size() > 12) return result;
        backtracking(s, 0, 0);
        return result;
    }
};
```

$a=b$
$$
\begin{pmatrix}
3 & 5 & 7 &  \\
5 & 8 & 9 \\

\end{pmatrix}
$$
