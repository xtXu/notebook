# 贪心算法
#leedcode #algorithm #greedy
## LeetCode 455 分发饼干
题目链接：[455](https://leetcode.cn/problems/assign-cookies/)  
思路：为了喂饱更多的小孩，饼干要物尽其用，大尺寸的饼干分给他能满足的最大胃口的小孩。  
代码：
```cpp
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end(), greater<int>());
        sort(s.begin(), s.end(), greater<int>());

        int i=0, j=0;
        int num = 0;
        while (i < g.size() && j < s.size()) {
            if (s[j] >= g[i]) {
                num++;
                j++;
            }
            i++;
        }
        return num;
    }
};
```
## LeetCode 376 摆动序列
题目链接：[376](https://leetcode.cn/problems/wiggle-subsequence/)  
思路：将整个数组画为折线图，可以看到，最长的摆动序列即为首末元素加上中间的波峰波谷。末尾元素一定能连到前一个峰/谷，因此可直接加入序列。头元素
代码：
```cpp

```
## LeetCode 53 最大子数组和
题目链接：[53](https://leetcode.cn/problems/maximum-subarray/)  
思路：对数组元素逐个累加为`count`，若`count>0`，则往后继续累加一定比只累加后续元素大。但如果`count<0`，那么一定会拖累后续元素累加的和。因此，当 `count<0`时就重置为0。最大和`result`通过每次比较当前记录的`result`和`count`来记录。  
代码：
```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int result = INT32_MIN;
        int count = 0;
        for (int i=0; i<nums.size(); ++i) {
            count += nums[i];
            if (count > result) result = count;
            if (count < 0) count = 0;
        }
        return result;
    }
};
```
## LeetCode 122 买卖股票的最佳时机 II
题目链接：[122](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)  
### 方法1 波谷买波峰卖
思路：将每天的价格画成折线图，找到波峰和波谷，波谷买入，波峰卖出。若第一个波峰早于第一个波谷，则第一天需买入。若最后一个为波谷，则最后一天需卖出。因此，可记录每次转折时的状态，接下来若遇到与记录状态相反的状态则进行买入/卖出操作，并记录新的状态。  
代码：
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int result = 0;
        
        int curdiff = 0;
        int prediff = 0;
        int in;
        for (int i=0; i<prices.size()-1; ++i) {
            curdiff = prices[i+1] - prices[i];
            if (curdiff > 0 && prediff <= 0) {
                in = i;
                prediff = curdiff;
            }
            if (curdiff < 0 && prediff > 0) {
                result += prices[i] - prices[in];
                prediff = curdiff;
            }
        }
        if (prediff > 0) result += prices[prices.size()-1] - prices[in];
        return result;
    }
};
```
### 方法2 分解
思路：将利润分解。假设第`i`天买，第`j`天卖，则总利润等于`i~i+1,i+1~i+2,...,j-1~j`的利润。因此每天都先卖再买，可以算出每天的利润，将其中的正利润相加即可得到最大利润。
代码：
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int result = 0;
        for (int i=1; i<prices.size(); ++i) {
            int profit = prices[i] - prices[i-1];
            if (profit > 0) result += profit;
        }
        return result;
    }
};
```