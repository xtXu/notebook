# 贪心算法
#leedcode #algorithm #greedy
## LeetCode 455 分发饼干
题目链接：[455](https://leetcode.cn/problems/assign-cookies/)  
思路：为了喂饱更多的小孩，饼干要物尽其用，大尺寸的饼干分给他能满足的最大胃口的小孩。  
代码：
```cpp
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end(), greater<int>());
        sort(s.begin(), s.end(), greater<int>());

        int i=0, j=0;
        int num = 0;
        while (i < g.size() && j < s.size()) {
            if (s[j] >= g[i]) {
                num++;
                j++;
            }
            i++;
        }
        return num;
    }
};
```
## LeetCode 376 摆动序列
题目链接：[376](https://leetcode.cn/problems/wiggle-subsequence/)  
思路：将整个数组画为折线图，最长的摆动序列即为首末元素加上中间的波峰波谷。对于梯形情况，从不变到递增记为波谷，不变到递减记为波峰。末尾元素一定能找到前一个峰/谷，因此默认加入序列。当第一次出现递增、递减状态，即`prediff=0, curdiff!=0`时，记录当前状态，并将首元素加入序列。此后，一旦`curdiff`与`prediff`相反，说明找到峰/谷，该元素加入序列，并记录状态。注意，为了处理不严格单调序列中的元素相等情况，`prediff`只有在找到峰/谷时才进行更新。
代码：
```cpp
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        int result = 1;

        int prediff = 0;
        int curdiff = 0;

        for (int i=0; i<nums.size()-1; ++i) {
            curdiff = nums[i+1] - nums[i];

            if (curdiff > 0 && prediff <= 0) {
                result++;
                prediff = curdiff;
            }
            if (curdiff < 0 && prediff >= 0) {
                result++;
                prediff = curdiff;
            }
        }
        return result;
    }
};
```
## LeetCode 53 最大子数组和
题目链接：[53](https://leetcode.cn/problems/maximum-subarray/)  
思路：对数组元素逐个累加为`count`，若`count>0`，则往后继续累加一定比只累加后续元素大。但如果`count<0`，那么一定会拖累后续元素累加的和。因此，当 `count<0`时就重置为0。最大和`result`通过每次比较当前记录的`result`和`count`来记录。  
代码：
```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int result = INT32_MIN;
        int count = 0;
        for (int i=0; i<nums.size(); ++i) {
            count += nums[i];
            if (count > result) result = count;
            if (count < 0) count = 0;
        }
        return result;
    }
};
```
## LeetCode 122 买卖股票的最佳时机 II
题目链接：[122](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)  
### 方法1 波谷买波峰卖
思路：将每天的价格画成折线图，找到波峰和波谷，波谷买入，波峰卖出。若第一个波峰早于第一个波谷，则第一天需买入。若最后一个为波谷，则最后一天需卖出。因此，可记录每次转折时的状态，接下来若遇到与记录状态相反的状态则进行买入/卖出操作，并记录新的状态。  
代码：
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int result = 0;
        
        int curdiff = 0;
        int prediff = 0;
        int in;
        for (int i=0; i<prices.size()-1; ++i) {
            curdiff = prices[i+1] - prices[i];
            if (curdiff > 0 && prediff <= 0) {
                in = i;
                prediff = curdiff;
            }
            if (curdiff < 0 && prediff > 0) {
                result += prices[i] - prices[in];
                prediff = curdiff;
            }
        }
        if (prediff > 0) result += prices[prices.size()-1] - prices[in];
        return result;
    }
};
```
### 方法2 分解
思路：将利润分解。假设第`i`天买，第`j`天卖，则总利润等于`i~i+1,i+1~i+2,...,j-1~j`的利润。因此每天都先卖再买，可以算出每天的利润，将其中的正利润相加即可得到最大利润。
代码：
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int result = 0;
        for (int i=1; i<prices.size(); ++i) {
            int profit = prices[i] - prices[i-1];
            if (profit > 0) result += profit;
        }
        return result;
    }
};
```
## LeetCode 55 跳跃游戏
题目链接：[55](https://leetcode.cn/problems/jump-game/)  
思路：为了确定是否能到终点，重点应关注可跳的覆盖范围，而不是具体跳几步。因此，可从头遍历数组，每移动一个单位，都更新最大覆盖范围；为了确定覆盖范围内都能跳到，移动应仅在当前的覆盖范围内进行。这样，当覆盖范围达到数组末尾时则能成功到达；若移动超出了覆盖范围，则说明后面的都无法到达。
代码：
```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int cover = 0;
        for (int i=0; i<=cover; ++i) {
            cover = max(cover, i+nums[i]);
            if (cover >= nums.size()-1) return true;
        }
        return false;
    }
};
```
## LeetCode 45 跳跃游戏 II
题目链接：[45](https://leetcode.cn/problems/jump-game-ii/)  
### 方法1 记录到达每个位置的最小步数
思路：用一个数组记录到达每个位置的最小步数。参考[LeetCode 55 跳跃游戏](#LeetCode%2055%20跳跃游戏)的覆盖范围更新方式。假设在`i`位置，覆盖范围首次更新到了`j`，则到达`j`的最小步数为到达`i`的最小步数`+1`。  
代码：
```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        vector<int> min_jump(nums.size());
        int cover = 0;
        if (nums.size() == 1) return 0;
        for (int i=0; i<=cover; ++i) {
            if (i+nums[i] >= nums.size()-1) return min_jump[i]+1;
            if (i+nums[i] <= cover) continue;
            int last_cover = cover;
            cover = i+nums[i];
            for (int j=last_cover+1; j<=cover; ++j) {
                min_jump[j] = min_jump[i]+1;
            }
        }
        return -1;
    }
};
```
### 方法2
思路：。  
代码：
```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        int curDistance = 0;
        int nextDistance = 0;
        int cnt = 0;
        if (nums.size() == 1) return 0;
        for (int i=0; i<nums.size(); ++i) {
            nextDistance = max(nextDistance, nums[i]+i);
            if (i == curDistance) {
                cnt ++;
                curDistance = nextDistance;
                if (nextDistance >= nums.size()-1) break;
            }
        }
        return cnt;
    }
};
```